# 2019.12.13

## 상속구문, 제어자

- Scanner - next(), nextInt(), nextDouble(), nextLine()

  readLine() : String 	=>	무조건 스트링으로 입력됨

  숫자로 변환하는 작업 필요

  공백 오류 조심해서 nextLine() 해줘야함



### [상속 구문]

- 자바의 모든 객체들은 상속이라는 객체지향 언어의 특징을 지향한다.

- 자바에서 생성되는 모든 객체들은 기본적으로 java.lang.Object 이라는 객체를 상속하게 된다.

- 클래스 헤더에 extends라는 절을 확인하여 부모 클래스를 설정하는데 하나의 부모 클래스만 설정 가능하다.

- 조상으로부터 물려받은 메서드들은 피룡에 따라 대체할 수 있다.

  메서드 오버라이딩(메서드 오버로딩과 메서드 오버라이딩은 다르다.)

  오버라이딩 ex)

  ```java
  String getLocation() {
  		return "x :" + x + ",y : "+y;
  }		
  	String getLocation() { 
  		return super.getLocation() + ", z :" + z;
  		}
  ```

- 어떤 클래스든 객체를 생성하면 해당 클래스만 메모리를 할당하는 것이 아니라 조상 클래스들도 메모리를 할당한다.

- 모든 생성자는 호출하게 된다면 Object 생성자를 제외하고 모두 조상의 생성자부터 호출하며 내려온다.

- 조상을 호출할 때 argument를 안받는 생성자를 호출하며 내려온다 **

  => 이럴때는 super메서드를 통해 직접 호출한다. (반드시 첫번째 행에 있어야 한다)

- 자손 클래스 객체 생성시 생성자 메서드가 호출되면 바로 조상 클래스의 생성자도 호출된다. 내부적으로는 argument없는 생성자가 호출되는데 다른 생성자를 호출하려는 경우 super()라는 메서드를 실행한다.

- 객체를 참조하는 용도 : this, super

- 객체를 초기화하는 용도로 사용된느 생성자 메서드 호출 : this(), super()

  this(), super() : 생성자 안에서만 호출 가능하다(첫번째 행에서만)

  this, super : 객체 생성 시점에 초기화된다. static메서드에서는 사용이 불가능하다. non-static메서드와 생성자 메서드에서만 사용 가능하다.

- this를 호출하고 있다면 super를 호출할 이유가 없다.(this에서 이미 왔다갔다 하고 있기 때문)

#### 컴파일러

- 자바의 실행파일은 바이트코드 실행파일이라고 한다. JVM이 운영체제에 알맞게 해석해서 실행시키기 때문이다.(일반적으로 운영체제가 실행하는 파일은 바이너리 파일이라고 한다.)
- 자바의 구문에 맞춰서 필요한 부분을 채워준다.(있어야 할 게 없을때)



### [제어자]

- 제어자란? => 클래스, 메서드, 변수 앞에 설정되어 접근 가능 여부와 사용방식을 제어하는 구문(생략 가능하다)

- 종류

  - 접근 제어자 : public, protected, (default), private => 하나만 지정 가능
  - 활용 제어자 : final, static, abstract, trasient, synchronized, ...

  [제어자] class 클래스명 extends 부모클래스명 {

  ​			[제어자] 멤버변수 선언

  ​			[제어자] 생성자 메서드 정의

  ​			[제어제] 메서드 정의

  }

  [public, final, abstract] class 클래스명 extends 부모클래스명 {

  ​			[모든 접근 제어자, final, static] 멤버변수 선언

  ​			[모든 접근 제어자] 생성자 메서드 정의

  ​			[모든 접근 제어자, static, final, abstract] 메서드 정의

  }

- 접근 제어자 + 활용 제어자 , 활용 제어자 + 활용 제어자도 사용 가능하다(의미가 상반된 경우가 아닐때)

- default - 접근 제어자를 생략한 경우

- 클래스에는 접근제어자를 두 가지만 설정 가능 : public or (default)

  public 클래스 : 누구나 접근 가능

  (default) 클래스 : 동일 패키지내의 클래스만 접근 가능

- final : 제어자로서의 final = 변경할 수 없는, 마지막의

  abstract : 반드시 변경해야 하는, 마지막이 아닌, 미완성의

  => 위 둘은 절대 같이 올 수 없다.

  final 클래스 : 상속 불가, 객체 생성은 가능

  abstract 클래스 : 객체 생성 불가, 상속만 가능

- 변수 앞에 오는 제어자

  public : 누구나 접근 가능

  protected : 동일 패키지 이거나 자손이면 접근 가능

  (default) : 동일 패키지 이어야만 접근 가능

  private : 자손이든 객체를 생성한 클래스든 접근 불가

  ​				멤버가 정의된 클래스 내에서만 사용 가능

  non-static 변수를 사용할 때 private 변수를 자주 쓴다.

``` java
+ : public
# : protected
(), ~ : (default)
- : private
```

- 메서드 이름에 언더라인이 있는 것은 static을 표현한 것이다.
- static, final을 함께 지정하여 상수를 만든다.

```java
ex) public class Math {
		public final static double PI = 3.141592;
}
```

- 메서드에

  final : 자손에 의해 오버라이딩이 불가능한 메서드를 정의

  abstract : 자손에 의해 반드시 오버라이딩 해야하는 메서드를 정의

  ​				메서드의 헤더만 정의되고 바디가 없는 메서드

  ​				(그때 그때 넣어서 써라)

- 다형성 => 접근 제어자는 좁아질 수는 있지만 더 넓어질 수는 없다.
- 상속 vs 포함 = > 자바의 정석ppt 7-1